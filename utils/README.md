# Cloud Native Utils (Go Edition)

| **Pattern**           | **Category**          | **Description**                                                                 | **When to Use**                                                                                                                                          |
|-----------------------|-----------------------|---------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Cache**             | Data                 | Stores frequently accessed data in a high-speed storage layer to improve performance. | Use when you need to reduce latency and the cost of accessing frequently used data.                                                                    |
| **CQRS**              | Data                 | Separates read and write operations to improve scalability and performance.     | Use when you want to optimize read and write operations independently, especially for systems with high read-to-write ratios.                          |
| **Sharding**          | Efficiency           | Distributes data across multiple storage units or services to balance load.     | Use when you need to handle large datasets or workloads, distributing them across multiple systems or nodes for better scalability and fault tolerance.    |
| **Split**             | Efficiency           | Divides a stream or data set into smaller parts for concurrent processing.      | Use when you need to divide data into chunks to enable parallel or concurrent processing for improved performance.                                        |
| **Generate**          | Efficiency           | Creates or generates a stream of data or tasks to be processed.                 | Use when you need to generate a sequence of values or tasks for further processing, typically in bulk operations.                                        |
| **Merge**             | Efficiency           | Combines multiple streams of data into one.                                     | Use when you have multiple sources of data or tasks that need to be processed together, such as aggregating results from different services or streams.    |
| **Process**           | Efficiency           | Executes a function concurrently or in parallel across multiple tasks or data points. | Use when you want to run multiple tasks simultaneously, either in a single process (concurrent) or across multiple processes or systems (parallel). This is ideal for independent tasks that can be executed simultaneously for improved throughput. |
| **Health Checks**     | Observability        | Regularly checks the health of services and components.                        | Use when you need to monitor system health and detect failures early.                                                                                   |
| **Distributed Tracing** | Observability      | Traces requests across multiple services to identify bottlenecks and failures.  | Use when debugging performance issues or identifying slowdowns in microservices-based architectures.                                                    |
| **Centralized Logging** | Observability      | Aggregates logs from various components for easier debugging and monitoring.    | Use when you need a unified view of application logs to diagnose issues efficiently.                                                                    |
| **Metrics Aggregation** | Observability      | Collects and analyzes system metrics to monitor performance and predict failures. | Use when you want to monitor trends and detect anomalies in system behavior.                                                                            |
| **Failover**          | Resilience           | Redirects traffic to a backup instance in case of failure.                      | Use when high availability is critical, and you want to ensure service continuity during component failures.                                             |
| **Bulkhead**          | Resilience           | Isolates system components so that a failure in one doesnâ€™t affect others.      | Use when you want to prevent cascading failures and ensure critical components remain operational even if others fail.                                   |
| **Graceful Degradation** | Resilience        | Reduces functionality during partial system failures to maintain some level of service. | Use when partial functionality is preferable to complete failure.                                                                                       |
| **Authentication and Authorization** | Security | Ensures users and services are properly verified and authorized to access specific resources. | Use when you need to control and verify access to sensitive data or system functions.                                                                  |
| **Encryption**        | Security             | Encrypts data in transit and at rest to secure sensitive information.           | Use when transmitting sensitive data or storing private information to ensure confidentiality and compliance.                                            |
| **Audit Trail**       | Security             | Logs all user actions for tracking and identifying suspicious activities.       | Use when you need to track user behavior for compliance, security, or debugging purposes.                                                               |
| **Tokenization**      | Security             | Replaces sensitive data with a unique identifier (token) to protect it from exposure. | Use when handling sensitive data like credit card numbers, where reducing exposure risk is critical.                                                   |
| **Circuit Breaker**   | Stability            | Prevents repeated failures by temporarily stopping calls to a failing service.  | Use when you have an external service or resource that might intermittently fail, and you want to avoid overloading it while giving it time to recover.   |
| **Debounce**          | Stability            | Prevents multiple rapid invocations of a function by delaying the execution.    | Use when handling high-frequency events (like user inputs or system notifications) where only the last action in a burst is needed.                    |
| **Retry**             | Stability            | Automatically retries a failed operation a specified number of times.           | Use when operations may fail intermittently due to transient issues (e.g., network timeouts or temporary service unavailability).                        |
| **Throttle**          | Stability            | Limits the rate at which a function is executed, enforcing a steady flow.       | Use when you want to limit how often an action can occur (e.g., API rate limiting, controlling resource consumption).                                    |
| **Timeout**           | Stability            | Ensures a function or operation doesn't run indefinitely by setting a maximum allowed time. | Use when an operation has the potential to hang or take too long, and you need to enforce a time limit for safety or performance reasons.                |
